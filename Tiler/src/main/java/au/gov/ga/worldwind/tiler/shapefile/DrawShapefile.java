/*******************************************************************************
 * Copyright 2014 Geoscience Australia
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package au.gov.ga.worldwind.tiler.shapefile;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URL;

import javax.imageio.ImageIO;

import org.geotools.data.shapefile.ShapefileDataStore;
import org.geotools.data.shapefile.ShapefileDataStoreFactory;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.data.store.ContentFeatureCollection;
import org.geotools.data.store.ContentFeatureSource;
import org.opengis.feature.simple.SimpleFeature;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.LineString;
import com.vividsolutions.jts.geom.MultiPolygon;
import com.vividsolutions.jts.geom.Polygon;

/**
 * Utility that takes a shapefile tileset (generated by the ShapefileTiler in
 * ga-worldwind-suite's Tiler application) and renders the polygons to a PNG
 * raster. This is useful for QA of the shapefile tileset data.
 * 
 * @author Michael de Hoog (michael.dehoog@ga.gov.au)
 */
public class DrawShapefile
{
	public static void main(String[] args) throws IOException
	{
		String urlPrototype = "jar:file:///E:/DEM/worldwaterbodies_noaustralia_shp.zip!/%d/%04d/%04d_%04d.shp";
		//String urlPrototype = "file:///E:/World/water/worldwaterbodies_noaustralia_shp/%d/%04d/%04d_%04d.shp";
		UrlParameter[] urlParameters =
				new UrlParameter[] { UrlParameter.Level, UrlParameter.Row, UrlParameter.Row, UrlParameter.Column };
		Envelope bounds = new Envelope(-180, -90, 45, 90);
		Dimension size = new Dimension(2048, 1024);
		Point2D.Double scale = new Point2D.Double(size.getWidth() / (bounds.getMaxX() - bounds.getMinX()),
				-size.getHeight() / (bounds.getMaxY() - bounds.getMinY()));
		Point2D.Double offset = new Point2D.Double(-bounds.getMinX() * scale.x,
				size.getHeight() - bounds.getMinY() * scale.y);
		Rectangle tiles = new Rectangle(0, 384, 256, 128);
		int level = 9;

		File output = new File("E:/TEMP/allshapefiles_fixed2.png");

		BufferedImage image = new BufferedImage(size.width, size.height, BufferedImage.TYPE_BYTE_GRAY);
		Graphics2D g2 = image.createGraphics();

		for (int row = 0; row < tiles.height; row++)
		{
			for (int column = 0; column < tiles.width; column++)
			{
				URL input = new URL(getUrl(urlPrototype, urlParameters, level, column, row));

				ShapefileDataStore store = null;
				try
				{
					ShapefileDataStoreFactory factory = new ShapefileDataStoreFactory();
					store = (ShapefileDataStore) factory.createDataStore(input);
					ContentFeatureSource featureSource = store.getFeatureSource();
					ContentFeatureCollection featureCollection = featureSource.getFeatures();

					SimpleFeatureIterator features = featureCollection.features();
					try
					{
						Path2D.Double path = new Path2D.Double(Path2D.WIND_EVEN_ODD);
						while (features.hasNext())
						{
							SimpleFeature feature = features.next();
							Geometry geometry = (Geometry) feature.getDefaultGeometry();
							if (geometry instanceof MultiPolygon)
							{
								MultiPolygon mp = (MultiPolygon) geometry;
								addMultiPolygon(mp, path, offset, scale);
							}
							else if (geometry instanceof Polygon)
							{
								Polygon p = (Polygon) geometry;
								addPolygon(p, path, offset, scale);
							}
							else
							{
								throw new IllegalArgumentException("Unknown geometry type: "
										+ geometry.getClass().getSimpleName());
							}
						}
						g2.fill(path);
					}
					finally
					{
						features.close();
					}
				}
				catch (FileNotFoundException e)
				{
					//ignore
				}
				catch (Exception e)
				{
					System.out.println("Error drawing " + input + ": " + e.getLocalizedMessage());
				}
				finally
				{
					if (store != null)
					{
						store.dispose();
					}
				}
			}
		}

		g2.dispose();
		ImageIO.write(image, "png", output);
	}

	public enum UrlParameter
	{
		Level,
		Column,
		Row
	}

	private static String getUrl(String urlPrototype, UrlParameter[] urlParameters, int level, int column, int row)
	{
		Object[] parameters = new Object[urlParameters.length];
		for (int i = 0; i < urlParameters.length; i++)
		{
			UrlParameter parameter = urlParameters[i];
			switch (parameter)
			{
			case Level:
				parameters[i] = level;
				break;
			case Column:
				parameters[i] = column;
				break;
			case Row:
				parameters[i] = row;
				break;
			default:
				throw new IllegalStateException("Unknown url parameter: " + parameter);
			}
		}
		return String.format(urlPrototype, parameters);
	}

	private static void addMultiPolygon(MultiPolygon mp, Path2D.Double path, Point2D.Double offset, Point2D.Double scale)
	{
		for (int i = 0; i < mp.getNumGeometries(); i++)
		{
			Geometry g = mp.getGeometryN(i);
			if (g instanceof Polygon)
			{
				Polygon p = (Polygon) g;
				addPolygon(p, path, offset, scale);
			}
		}
	}

	private static void addPolygon(Polygon p, Path2D.Double path, Point2D.Double offset, Point2D.Double scale)
	{
		addLineString(p.getExteriorRing(), path, offset, scale);
		for (int j = 0; j < p.getNumInteriorRing(); j++)
		{
			addLineString(p.getInteriorRingN(j), path, offset, scale);
		}
	}

	private static void addLineString(LineString lineString, Path2D.Double path, Point2D.Double offset,
			Point2D.Double scale)
	{
		Coordinate coordinate = lineString.getCoordinateN(0);
		path.moveTo(offset.x + coordinate.x * scale.x, offset.y + coordinate.y * scale.y);
		for (int i = 1; i < lineString.getNumPoints(); i++)
		{
			coordinate = lineString.getCoordinateN(i);
			path.lineTo(offset.x + coordinate.x * scale.x, offset.y + coordinate.y * scale.y);
		}
		path.closePath();
	}
}

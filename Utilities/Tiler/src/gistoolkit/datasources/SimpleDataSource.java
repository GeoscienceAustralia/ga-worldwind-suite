/*
 *    GISToolkit - Geographical Information System Toolkit
 *    (C) 2002, Ithaqua Enterprises Inc.
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation;
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package gistoolkit.datasources;

import java.util.*;
import gistoolkit.common.*;
import gistoolkit.features.*;
import gistoolkit.projection.*;
import gistoolkit.datasources.filter.*;

/**
 * The SimpleDataSource implements the DataSource, and implements some
 * of the more tedious methods of it.
 * <p>
 * It handles Projections (Using the ToolkitProjection Engine),
 * and handles the getting and setting of the name, the projection, the insert and update methods,
 * and the filters.
 * </p>
 * <p>
 * To create an ReadOnly data source, subclassing the SimpleDataSource is the easiest way to go.
 * The only methods that must be overridden are the methods:
 * readEnvelope(), readShapes(), and getValidShapeTypes().  The rest of the plumming should be taken care of.
 * </p>
 * <p>
 * To create an Updateable data source, additional methods must be overridden, they include the doInsert, doUpdate, doDelete, doRollback, and doCommit methods.
 * Do not forget to overide the isUpdateable method to return true as the default is to return false.
 * </p>
 * <p>
 * Additional methods may be overridden to provide speed if the underlying data souce provides
 * similar capabilities.
 * </p>  
 * 
 * @author  bitterstorm
 */
public abstract class SimpleDataSource implements DataSource{
    
    /** Creates new SimpleDataSource */
    public SimpleDataSource() {
    }
    
    /** A name given to this data source to identify it. */
    private String myName = "Bartholamu";
    /**Gets the identifier string for the datasource.*/
    public String getName(){return myName;}
    /**Sets an identifier string for the datasource.*/
    public void setName(String inName) {myName = inName;}
    
    /**
     * The projection to use to convert the data from the projection it is in to either the projection for the current map,
     * or a projection that can be converted to the current map projection.
     */
    private Projection myFromProjection = new NoProjection();
    /**
     * Sets the projection to use to convert from the storage media, source projection.
     * It is expected that this projection will be run in reverse, to reverse project already projected data,
     * and that it will not change often so it is OK for this to be done just once.
     */
    public void setFromProjection(Projection inProjection) throws Exception{
        clearCache();
        myFromProjection = inProjection;
    }
    
    /** Returns the projection to use to convert from the datasource native projection to the display projection, or a basis projection for the display projection. */
    public Projection getFromProjection(){return myFromProjection;}
    
    
    /** Projection to use to convert from the datasource projection or a basis generated by the From Projection to the projection used by the map. */
    private Projection myToProjection = new NoProjection();
    
    /** Indicates that this datasource should cache it's shapes.  */
    private boolean myCached = true;
    /** Set to true if this datasource should cache it's shapes. */
    public void setCached(boolean inCached){myCached = inCached;}
    /** Returns true if this datasource is caching it's shapes. */
    public boolean getCached(){return myCached;}
    
    /** Indicates that the cache should be done after the final projection, instead of before. */
    private boolean myCachedProjected = true;
    /** Returs true if the dataset is supposed to cache the data projected. */
    protected boolean isCachedProjected(){return myCachedProjected;}
    
    /**
     * Allows another projection to be used to convert to the screen projection.  The CacheProjected flag indicates to the
     * Data source that the to projection will not be changing often, and it is OK to project once and cache it.  Setting this
     * flag to false indicates to the DataSource that the toProjection will be changing often.*/
    public void setToProjection(Projection inProjection, boolean inCacheProjected) throws Exception{
        if (myCachedProjected){
            clearCache();
            myToProjection = inProjection;
        }
        else myToProjection = inProjection;
        myCachedProjected = inCacheProjected;
    }
    public void setProjection(Projection inProjection)throws Exception {setToProjection(inProjection, true);}
    /** Returns the ToProjection. */
    public Projection getToProjection(){return myToProjection;}
    
    /** Project the dataset forward */
    public void projectForward(Projection inProjection, GISDataset inDataset) throws Exception{
        if (inProjection == null) return;
        if (inDataset == null) return;
        for (int i=0; i<inDataset.size(); i++){
            ShapeProjector.projectForward(inProjection, inDataset.getShape(i));
        }
        inDataset.resetEnvelope();
    }
    /** Project the dataset backward */
    public void projectBackward(Projection inProjection, GISDataset inDataset) throws Exception{
        if (inProjection == null) return;
        if (inDataset == null) return;
        for (int i=0; i<inDataset.size(); i++){
            ShapeProjector.projectBackward(inProjection, inDataset.getShape(i));
        }
        inDataset.resetEnvelope();
    }
    
    /** The filter to use when querying data from this data source. */
    private Filter myFilter = null;
    /** Get the filter used with this data source. */
    public Filter getFilter(){return myFilter;}
    /** Set the filter to use when querying data from this data source. */
    public void setFilter(Filter inFilter){
        myFilter = inFilter;
        clearCache();
    }
    protected GISDataset filterDataset(GISDataset inDataset){
        if (myFilter == null) return inDataset;
        if (inDataset == null) return inDataset;
        if (inDataset.size() == 0) return inDataset;
        GISDataset tempDataset = new GISDataset(inDataset.getAttributeNames(), inDataset.getAttributeTypes());
        for (int i=0; i<inDataset.size(); i++){
            Record tempRecord = inDataset.getRecord(i);
            if (myFilter.contains(tempRecord)){
                tempDataset.add(tempRecord);
            }
        }
        return tempDataset;
    }
    
    /**Used to cache the shapes from the data source so subsequent queries against the data source are quick.*/
    private GISDataset myCacheDataset = null;
    /** Return the cached data set. */
    protected GISDataset getCacheDataset(){return myCacheDataset;}
    /**
     * Used to indicate what area is valid for the cached data set.
     * Subsequent queries equal to or within this area will be queried from the cached set.
     * Queries outside this area will request a new GISDataset.
     */
    private Envelope myCacheEnvelope = null;
    /** Return the envelope of the cached dataset */
    protected Envelope getCacheEnvelope(){return myCacheEnvelope;}
    /** Set the cached data set and envelope.  This should be set after each new query.*/
    protected synchronized void setCache(GISDataset inDataset, Envelope inEnvelope){
        if (myCached){
            myCacheDataset = inDataset;
            myCacheEnvelope = inEnvelope;
        }
    }
    
    /** Clear the cache. */
    protected void clearCache(){
        myCacheDataset = null;
        myCacheEnvelope = null;
    }
    /** Retrieve the data from the cache that intersect these envelope.*/
    protected synchronized GISDataset queryFromCache(Envelope inEnvelope) {
        if (myCacheDataset == null) return new GISDataset();
        if (myCacheEnvelope == null) return new GISDataset();
        
        // if the envelopes are the same, then return the current one.
        if (myCacheEnvelope.isEqual(inEnvelope)) {
            return myCacheDataset;
        }
        
        // retrieve the attribute names from the current dataset
        GISDataset tempDataset = new GISDataset(myCacheDataset.getAttributeNames());
        Polygon tempPolygon = inEnvelope.getPolygon();
        
        // loop through the dataset retrieving the required shapes.
        int tempRejectCount = 0;
        for (int i = 0; i < myCacheDataset.size(); i++) {
            boolean tempAdd = false;
            
            // determine if the shape belongs in the dataset
            Shape tempShape = myCacheDataset.getShape(i);
            if (tempShape != null){
                if (tempShape instanceof Point){
                    Point tempPoint = (Point) tempShape;
                    if (inEnvelope.contains(tempPoint.getX(), tempPoint.getY())){
                        tempDataset.add(myCacheDataset.getRecord(i));
                        tempAdd = true;
                    }
                }
                else if (inEnvelope.contains(tempShape.getEnvelope())){
                    tempDataset.add(myCacheDataset.getRecord(i));
                    tempAdd = true;
                }
                else if (inEnvelope.overlaps(tempShape.getEnvelope())) {
                    if (tempPolygon.intersects(tempShape)){
                        tempDataset.add(myCacheDataset.getRecord(i));
                        tempAdd = true;
                    }
                }
            }
            if (! tempAdd){
                tempRejectCount++;
            }
        }
        // return the new dataset
        return tempDataset;
    }
    
    
    /**
     * Reads only the objects from the data source that intersect these envelopes.
     */
    public synchronized GISDataset readDataset(Envelope inEnvelope) throws Exception {
        if (inEnvelope == null) return readDataset();
        Envelope tempEnvelope = inEnvelope;
        if (myCacheEnvelope != null){
            if (myCachedProjected == false){
                tempEnvelope = ShapeProjector.projectBackward(myToProjection, inEnvelope);
                if (myCacheEnvelope.contains(tempEnvelope)){
                    GISDataset tempDataset = queryFromCache(tempEnvelope);
                    tempDataset = (GISDataset) tempDataset.clone();
                    projectForward(myToProjection, tempDataset);
                    return tempDataset;
                }
            }
            else {
                if (myCacheEnvelope.contains(tempEnvelope)){
                    return queryFromCache(tempEnvelope);
                }
            }
        }
        tempEnvelope = ShapeProjector.projectBackward(myToProjection, inEnvelope);
        // I have some concerns about this because the shape is not really a square at this point.
        // would be more efficient to convert to a polygon and then query from that.
        GISDataset tempDataset = readShapes(ShapeProjector.projectForward(myFromProjection, tempEnvelope));
        if (tempDataset != null){
            tempDataset = filterDataset(tempDataset);
            tempDataset = (GISDataset) tempDataset.clone();
            projectBackward(myFromProjection, tempDataset);
            if (myCachedProjected == false){
                setCache(tempDataset, tempEnvelope);
                tempDataset = (GISDataset) tempDataset.clone();
                projectForward(myToProjection, tempDataset);
            }
            else{
                projectForward(myToProjection, tempDataset);
                setCache(tempDataset, (Envelope) inEnvelope.clone());
            }
        }
        return tempDataset;
    }
    
    /**
     * Reads all the objects from the data source.
     */
    public GISDataset readDataset() throws Exception {
        GISDataset tempDataset = readShapes(null);
        tempDataset = filterDataset(tempDataset);
        projectBackward(myFromProjection, tempDataset);
        if (myCachedProjected == false){
            setCache(tempDataset, (Envelope) tempDataset.getEnvelope());
            tempDataset = (GISDataset) tempDataset.clone();
            projectForward(myToProjection, tempDataset);
        }
        else{
            projectForward(myToProjection, tempDataset);
            setCache(tempDataset, (Envelope) tempDataset.getEnvelope());
        }
        return tempDataset;
    }
    
    /** This method should return the shapes from the data source */
    protected abstract GISDataset readShapes(Envelope inEnvelope) throws Exception;
    
    /**Returns the bounding rectangle of all the shapes in the Data Source.*/
    public abstract Envelope readEnvelope() throws Exception;
    
    /** Returns the projected envelope. */
    public Envelope getEnvelope()throws Exception{
        Envelope tempEnvelope = readEnvelope();
        if (tempEnvelope == null) return tempEnvelope;
        if (myFromProjection != null){
            tempEnvelope = ShapeProjector.projectBackward(myFromProjection, tempEnvelope);
        }
        if (myToProjection != null){
            tempEnvelope = ShapeProjector.projectForward(myToProjection, tempEnvelope);
        }
        return tempEnvelope;
    }
    
    /** String to ensure that the data source name tag is constant */
    private static final String DATASOURCE_NAME = "DataSourceName";
    private static final String FROM_PROJECTION_NODE = "FromProjection";
    private static final String FROM_PROJECTION_CLASS = "FromProjection";
    private static final String FILTER_NODE = "Filter";
    private static final String FILTER_CLASS = "FilterClass";
    private static final String CACHED = "Cached";
    
    /** Get the configuration information for this data source  */
    public Node getNode() {
        Node tempRoot = new Node("SimpleDataSource");
        tempRoot.addAttribute(DATASOURCE_NAME, getName());
        tempRoot.addAttribute(CACHED, ""+myCached);
        
        // add the From Projection, it stays with the data source.
        Node tempFromProjectionNode = new Node(FROM_PROJECTION_NODE);
        if (myFromProjection != null){
            tempFromProjectionNode.addAttribute(FROM_PROJECTION_CLASS, myFromProjection.getClass().getName());
            Node tempProjNode = myFromProjection.getNode();
            if (tempProjNode != null){
                tempFromProjectionNode.addChild(tempProjNode);
            }
            tempRoot.addChild(tempFromProjectionNode);
        }
        
        // add the filter.
        Filter tempFilter = getFilter();
        if (tempFilter != null){
            Node tempFilterNode = new Node(FILTER_NODE);
            tempFilterNode.addAttribute(FILTER_CLASS, tempFilter.getClass().getName());
            Node tempNode = tempFilter.getNode();
            if (tempNode != null){
                tempFilterNode.addChild(tempNode);
            }
            tempRoot.addChild(tempFilterNode);
        }
        
        return tempRoot;
    }
    /** Set the configuration information for this data source  */
    public void setNode(Node inNode) throws Exception {
        if (inNode != null){
            myName = inNode.getAttribute(DATASOURCE_NAME);
            String tempString = inNode.getAttribute(CACHED);
            if (tempString != null){
                if (tempString.toUpperCase().startsWith("F")){
                    myCached = false;
                }
                else{
                    myCached = true;
                }
            }
            
            // check for the from projection.
            Node tempFromProjectionNode = inNode.getChild(FROM_PROJECTION_NODE);
            if (tempFromProjectionNode != null){
                String tempProjectionClass = tempFromProjectionNode.getAttribute(FROM_PROJECTION_CLASS);
                if (tempProjectionClass != null){
                    Projection tempProjection = (Projection) Class.forName(tempProjectionClass).newInstance();
                    Node[] tempNodes = tempFromProjectionNode.getChildren();
                    if (tempNodes.length > 0){
                        tempProjection.setNode(tempNodes[0]);
                    }
                    setFromProjection(tempProjection);
                }
            }
            
            // check for the filter
            Node tempFilterNode = inNode.getChild(FILTER_NODE);
            if (tempFilterNode != null){
                String tempFilterClass = tempFilterNode.getAttribute(FILTER_CLASS);
                if (tempFilterClass != null){
                    Filter tempFilter = (Filter) Class.forName(tempFilterClass).newInstance();
                    Node[] tempNodes = tempFilterNode.getChildren();
                    if (tempNodes.length > 0){
                        tempFilter.setNode(tempNodes[0]);
                    }
                    setFilter(tempFilter);
                }
            }
        }
    }
    
    
    /**Holds a list of the listeners to this datasource*/
    private Vector myListeners = new Vector();
    
    /**Adds a datasource listener to this datasource.*/
    public void addDataSourceListener(DataSourceListener inDataSourceListener) {
        myListeners.addElement(inDataSourceListener);
    }
    
    /**Removes the datasource lisener from this datasource.*/
    public void removeDataSourceListener(DataSourceListener inDataSourceListener) {
        myListeners.removeElement(inDataSourceListener);
    }
    
    /** Called to notify the listeners that the record has been read */
    protected void fireRead(Record inRecord){
        if (myListeners.size() > 0){
            DataSourceEvent tempEvent = new DataSourceEvent(inRecord);
            for (int i=0; i<myListeners.size(); i++){
                ((DataSourceListener) myListeners.elementAt(i)).recordRead(tempEvent);
            }
        }
    }
    /** Called to notify the listeners that the record has been inserted */
    protected void fireInsert(Record inRecord){
        if (myListeners.size() > 0){
            DataSourceEvent tempEvent = new DataSourceEvent(inRecord);
            for (int i=0; i<myListeners.size(); i++){
                ((DataSourceListener) myListeners.elementAt(i)).recordInserted(tempEvent);
            }
        }
    }
    /** Called to notify the listeners that the record has been updated */
    protected void fireUpdate(Record inRecord){
        if (myListeners.size() > 0){
            DataSourceEvent tempEvent = new DataSourceEvent(inRecord);
            for (int i=0; i<myListeners.size(); i++){
                ((DataSourceListener) myListeners.elementAt(i)).recordUpdated(tempEvent);
            }
        }
    }
    /** Called to notify the listeners that the record has been deleted */
    protected void fireDelete(Record inRecord){
        if (myListeners.size() > 0){
            DataSourceEvent tempEvent = new DataSourceEvent(inRecord);
            for (int i=0; i<myListeners.size(); i++){
                ((DataSourceListener) myListeners.elementAt(i)).recordDeleted(tempEvent);
            }
        }
    }
    /** Called to notify the listeners that a commit has occured */
    protected void fireCommit(){
        if (myListeners.size() > 0){
            DataSourceEvent tempEvent = new DataSourceEvent(null);
            for (int i=0; i<myListeners.size(); i++){
                ((DataSourceListener) myListeners.elementAt(i)).transactionCommitted(tempEvent);
            }
        }
    }
    /** Called to notify the listeners that a rollback has occured */
    protected void fireRollBack(){
        if (myListeners.size() > 0){
            DataSourceEvent tempEvent = new DataSourceEvent(null);
            for (int i=0; i<myListeners.size(); i++){
                ((DataSourceListener) myListeners.elementAt(i)).transactionRolledBack(tempEvent);
            }
        }
    }
    
    /** Determines if this datasource is updateable. By default it is not, so this method always returns false.*/
    public boolean isUpdateable() {return false;}
    
    /** Insert the record into the data source. By default this is a read only data source, so this method does nothing. */
    public void doInsert(Record inRecord) throws Exception {}
    
    /** Update the data source with the changed record. By default this is a read only data source, so this method does nothing. */
    public void doUpdate(Record inRecord) throws Exception {}
    
    /**Delete this record from the database. By default this is a read only data source, so this method does nothing.*/
    public void doDelete(Record inRecord) throws Exception {}
    
    /**Commit all changes since the last commit. This is a read only data source by default, so this method does nothing. */
    public void doCommit() throws Exception {}
    
    /**Rollback any changes to this datasource since the last commit.*/
    public void doRollback() throws Exception {}
    
    /**Commit all changes since the last commit. This is a read only data source by default, so this method does nothing. */
    public void commit() throws Exception {
        doCommit();
    }
    
    /**Rollback any changes to this datasource since the last commit.*/
    public void rollback() throws Exception {
        doRollback();
        clearCache();
    }
    
    /**Return the array of shape types that are valid for this data source */
    String[] myTypes = {Shape.NULLSHAPE,Shape.POINT,Shape.MULTIPOINT,Shape.LINESTRING,Shape.MULTILINESTRING,Shape.POLYGON,Shape.MULTIPOLYGON,Shape.RASTER};
    public String[] getValidShapeTypes(){
        return myTypes;
    }
    
    private boolean getShapeTypeContains(String inType){
        String[] tempTypes = getValidShapeTypes();
        for (int i=0; i<tempTypes.length; i++){
            if (tempTypes[i] == inType){
                return true;
            }
        }
        return false;
    }
    
    /**Inserts the given record into the datasource.*/
    public void insert(Record inRecord) throws Exception {
        if (!isUpdateable()) throw new Exception("This data source is not updateable");
        if (inRecord == null) return;
        
        // reverse project the shape sent in.
        ShapeProjector.projectBackward(myToProjection, inRecord.getShape());
        ShapeProjector.projectForward(myFromProjection, inRecord.getShape());
        
        // ensure that the shape sent in is the correct type
        // if the record sent in is null, check to ensure that this data source supports nulls.
        if (inRecord.getShape() == null){
            if (getShapeTypeContains(Shape.NULLSHAPE) == true) doInsert(inRecord);
            else throw new Exception("Null Shapes are not supported by the data source");
            return;
        }
        
        // erase the cache as it needs to be updated.
        setCache(null, null);
        
        // ensure that the data source allows this type of shape.
        if (getShapeTypeContains(inRecord.getShape().getShapeType())){
            doInsert(inRecord);
            fireInsert(inRecord);
            clearCache();
            return;
        }
        
        // if the record sent in is a Point, ensure that this data source supports Points.
        if (inRecord.getShape() instanceof Point){
            // check for multipoints
            if (getShapeTypeContains(Shape.MULTIPOINT) == true){
                Point[] tempPoints = {(Point) inRecord.getShape()};
                inRecord.setShape(new MultiPoint(tempPoints));
                doInsert(inRecord);
                fireInsert(inRecord);
                clearCache();
                return;
            }
        }
        
        // if the record sent in is a LineString, ensure that the data source supports LineStrings.
        if (inRecord.getShape() instanceof LineString){
            if (getShapeTypeContains(Shape.MULTILINESTRING)){
                LineString[] tempLineStrings = {(LineString) inRecord.getShape()};
                inRecord.setShape(new MultiLineString(tempLineStrings));
                doInsert(inRecord);
                fireInsert(inRecord);
                clearCache();
                return;
            }
        }
        
        // if the record sent in is a Polygon, ensure that the data source supports Polygons.
        if (inRecord.getShape() instanceof Polygon){
            if (getShapeTypeContains(Shape.MULTIPOLYGON)){
                Polygon[] tempPolygons = {(Polygon) inRecord.getShape()};
                inRecord.setShape(new MultiPolygon(tempPolygons));
                doInsert(inRecord);
                fireInsert(inRecord);
                clearCache();
                return;
            }
        }
        
        throw new Exception("The shape type of "+inRecord.getShape().getShapeType()+" is not supported by this data source");
    }
    
    /** Update the given record in the data source.*/
    public void update(Record inRecord) throws Exception {
        if (!isUpdateable()) throw new Exception("This data source is not updateable");
        if (inRecord == null) return;
        
        // reverse project the shape sent in.
        ShapeProjector.projectBackward(myToProjection, inRecord.getShape());
        ShapeProjector.projectForward(myFromProjection, inRecord.getShape());
        
        // update the record
        doUpdate(inRecord);
        clearCache();
        return;
    }
    
    /** Delete the given record from the data source. */
    public void delete(Record inRecord) throws Exception{
        if (!isUpdateable()) throw new Exception("This data source is not updateable");
        if (inRecord == null) return;
        
        // reverse project the shape sent in.
        ShapeProjector.projectBackward(myToProjection, inRecord.getShape());
        ShapeProjector.projectForward(myFromProjection, inRecord.getShape());
        
        // update the record
        doDelete(inRecord);
        fireDelete(inRecord);
        clearCache();
        return;
    }
    
    /**
     * Get the default style to use with this datasource.
     *
     * The default style for the layer is a black line whith a white fill.  This is usually a less than optimal style to use for a particular layer.
     * Further, there are some layers that are displayed in such a manner as to appear non functional using this style.  If this data source knows about
     * a better default than the one provided by the layer, then it can create and return that style here and the layer will use it instead of the black lines/white fill
     * it would normally use.
     *
     * If the black lines/white fill style is fine then just return null and the layer will return the correct style.
     */
    public gistoolkit.display.Style getStyle() {
        return null;
    }
}
